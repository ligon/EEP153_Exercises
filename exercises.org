* [EEP153] Week 0
  :PROPERTIES:
  :EXPORT_FILE_NAME: week0.ipynb
  :END:
** Learning goals
   1. Open a =jupyter= notebook on =datahub.berkeley.edu=.
   2. Understand simple =python= expressions.
   3. Work with lists & dictionaries.
   4. Work with =pandas.DataFrames=.
   5. Submit indication of completion.

*** Simple Expressions
Python is a general purpose language, extended via /modules/.
One important aspect of python are /expressions/.  Here are some examples:
#+begin_src ipython
# Arithmetic 
1 + 1

# String (Delineated using single- or double-quotes)
"Hello world!"

# To see output, using a "print" statement:
print(1+1)
print("Hello" + "world!")
#+end_src
   
The above provides examples of:
   - Comments :: Text that begins with a "#" character.
   - Function calls :: Something that takes arguments (in parentheses)
                       and returns some output.  Here "print" is a
                       function.
   - Objects :: 1 and "Hello" are examples of objects.
   - Operators :: "+" is an operator.  Notice that it functions
                  differently depending on what it's operating on;
                  that's because its operation depends on the =type=
                  of the objects (/operands/) it's operating on.  

Predict the output of the following two lines:
#+begin_src ipython
print(type(1+1))
print(type("Hello"))
#+end_src

*** Lists
Strings and integers are simple examples of different data types (or
objects).  A very important type that is more complicated are
=lists=.  Here are some examples.  Examine them, and predict the output:
#+begin_src ipython
a = [1,2,3]
b = ["Hello","world"]

c = a + b
print(c)
print(len(c))  # Here len returns the "length" of the list.
#+end_src


Extra optional practice to refresh yourself with list manipulation and slicing.
Examine these first, then predict the output.
#+begin_src ipython
print(c[2]) # Remember how Python counts arrays.
print(c[1:2]) # Why does Python only return one item instead of two?
print(b[0]*4)
print(c[0::2])
print(list(map(lambda x: x*2,a)))
#+end_src

*** Dictionaries

Another very basic kind of compound object are =dicts= (dictionaries;
also called associative arrays or hashes in other languages).  Predict
the output:

#+begin_src ipython :results output
d = {'name': "Barney", 'species': "Dinosaur", 'age': 27, 'color': "Purple"}

print("{name} the {species} is {color}.".format(**d))
#+end_src

*** DataFrames

A much more complicated data structure is provided by a module called
=pandas=; you can find a quick tutorial at
http://pandas.pydata.org/pandas-docs/version/0.23/10min.html.  The
DataFrame object will be very important for us.

The =pandas= module provides a data structure called a =DataFrame=.
These are basically rectangular arrays of data, with names for rows
and columns, rather like a spreadsheet.  In fact, one important thing
one can do with DataFrames is to import data /from/ spreadsheets.
#+begin_src ipython :session
import pandas as pd

# Try looking at https://docs.google.com/spreadsheets/d/1ObK5N_5aVXzVHE7ZXWBg0kQvPS3k1enRwsUjhytwh5A in your browser.
SHEET = "https://docs.google.com/spreadsheets/d/1q1ikP1CXCcLf_Tq6VbhoskOYRvn_nDU5MHStIoVzMgA"

# The following line goes on-line and turns the spreadsheet into a pandas DataFrame:
df = pd.read_csv(SHEET + "/export?format=csv")

# This line will show us only the first five rows of data. Try removing .head() to see the full list of items.
# Guess what happens if you replace .head() with .tail(). Try it out!
df.head()
#+end_src

If this worked (!) you should be able to see some data from a recent
shopping trip of mine.  What are the different variables available in
the DataFrame =df=?  They correspond to the /columns/ of the spreadsheet.

#+begin_src ipython :session
df.columns
#+end_src

Now, what else can we do?  Let's figure out how much my total grocery
bill was:

#+begin_src ipython :session
df['Price'].sum()
#+end_src

Let's say I'm on a budget. Naturally, we'd want to identify the item(s)
I'm spending the most on. We can sort the values to investigate further.

#+begin_src ipython :session
# Note that we're indicating we want to sort by the 'Price' column and specify that it should be in descending order.
df.sort_values(by='Price', ascending=False).head()
#+end_src

Everything here looks straightforward, but let's take a closer look at
Red Endive and calculate the price per pound to make comparison easier.

#+begin_src ipython :session
# This line selects the 7th item in the dataframe (note the index number is 6 because we start counting at 0 when we use Python)
# and selects the 'Price' value for this particular item. It divides it by 'Quantity' to get the price per pound.
df.iloc[6]['Price']/df.iloc[6]['Quantity']
#+end_src

You'll find throughout the semester that unit price is a pretty useful statistic
to calculate. Let's do it for all the items on this grocery list. Thankfully we
don't have to do this one by one.

#+begin_src ipython :session
# This line creates a new column in our dataframe named 'Unit Price' and populates each row with the respective price value 
# divided by the quantity value.
df['Unit Price'] = df['Price']/df['Quantity']
df.head()
#+end_src

Almost there! Let's pare down our dataframe to look more friendly to the eye. We
don't want to see the following columns: Date, Location, NDB. Also, we only want to see
the first five items of the dataframe. 

In the previous blocks, we used .iloc which stands for index (or integer) location. We used integers to specify which
columns we wanted. In this section, we'll use .loc which allows us to use column labels. For extra practice, try to
achieve the same result but by using .iloc instead.

#+begin_src ipython :session

# Note that in both the .iloc and .loc syntax, the first set of parameters refer to rows and the second set refer to columns.
df.loc[0:5, ['Food', 'Quantity', 'Units', 'Price', 'Unit Price']]
#+end_src

Here's one last exercise that might be useful. Often times you will only want to view data
that fits a certain criterion. In this case, let's only look at items where the unit price
is less than 1.

#+begin_src ipython :session
# This line will return all rows in the dataframe where the Unit Price is < 1. Using what we've covered prior,
# modify the view of this dataframe to only include Food and Unit Price.
df[df['Unit Price'] < 1]
#+end_src

Extra things to refresh that may be helpful for Project 1: basic visualizations, datatypes, index, joins.

*** Final words
Throughout this class, you will be exposed to a variety of Python modules and tools and the data that you work with
may or may not be cleaned. In any case, learning how to find and use online documentation/resources is a
valuable skill that will benefit you greatly in this course and beyond. Be sure to utilize our course =piazza=
for any questions you might have - there's a good chance a peer may have a similar question or have the answer.
As the semester goes on, course staff will update the "Useful Links/Resources" post with any outside Python resources 
that may be helpful for the whole class.

* [EEP153] Week 1
  :PROPERTIES:
  :EXPORT_FILE_NAME: week1.ipynb
  :END:
  Some programming learning goals for week 1:
   1. Decrypting Google Drive API credentials using =GPG=
   2. Using =gspread= to read Google Spreadsheet data
   3. Using =gspread= to write Google Spreadsheet data

** Credential decryption
   Protecting access to sensitive information is paramount to any
   organization's security. In this class, the information we will be
   sharing with you is not highly sensitive. However, learning how to
   work with decryption is a handy skill that you might find useful
   after this course.

   In this cell, we will run a shell command that leverages the GPG
   module to decrypt the file =students-9093fa174318.json.gpg= located
   in your server. Notice how we do this with the =!= symbol before
   typing in the rest of the code. Be sure to insert the passphrase
   provided to you.

#+begin_src ipython
# Replace PASSPHRASE in the next comment with the secret we'll share
# with you in class.

!gpg -d --batch --passphrase "PASSPHRASE" students-9093fa174318.json.gpg > students-9093fa174318.json
#+end_src

   Take a look in your jupyter server directory and you should see a
   new file named =students-9093fa174318.json=. Protect this file
   carefully, as anyone who has this can now access the spreadsheets
   we'll introduce you to in this course.

** Reading Google Spreadsheet data

   In this section, we'll read data from Google Spreadsheet using a
   module called =GSpread=. You're not expected to be fully understand
   all the functions of this module, though knowing how to read
   spreadsheet data with basic =GSpread= functions may be helpful for
   this project and beyond.

*** Initial Set-up
   In this first cell, we provide the initial setup that will allow
   you to access this spreadsheet:
   https://docs.google.com/spreadsheets/d/1xoAe1BlXb7m3ZSB-Tm5XkkVn0W6xkS3y5zl48TqVSsk/edit?usp=sharing. 

#+begin_src ipython
# !pip install gspread
import gspread
from oauth2client.service_account import ServiceAccountCredentials

scope = ['https://spreadsheets.google.com/feeds',
         'https://www.googleapis.com/auth/drive']
#+end_src

   Now, we'll input the credentials you decrypted in the previous
   section and specify the spreadsheet we want to open in Python.

#+begin_src ipython
# This should be the default .json file pathway, but feel free to change
# json_file if your pathway if different.

json_file = 'students-9093fa174318.json'
spreadsheet = '1xoAe1BlXb7m3ZSB-Tm5XkkVn0W6xkS3y5zl48TqVSsk'
credentials = ServiceAccountCredentials.from_json_keyfile_name(json_file, scope)
gc = gspread.authorize(credentials)

sh = gc.open_by_key(spreadsheet)

#+end_src

*** Accessing Values
   Our spreadsheet is now open by an instance of =gspread=, and you
   can access it in the variable =sh=. To explore this data, you
   might find more value exploring it in your browser. A couple
   technicalities to be aware of:
      -  A =spreadsheet= is the overall container that holds multiple
         worksheets.
      -  A =worksheet= is a single tab in a spreadsheet.

#+begin_src ipython
# This cell provides you with a list of all worksheets contained in the
# spreadsheet. If you already know which spreadsheet you want to access,
# you can ignore this cell.

sh.worksheets()
#+end_src

#+begin_src ipython
# This cell allows you to access a particular spreadsheet within the worksheet.
# Even if your spreadsheet has only worksheet, you still must specify the
# worksheet you wish to read data from.

wks = sh.worksheet("Expenditures")

# Alternatively, you can use the following code snippets to achieve the same result.
# wks = sh.get_worksheet(0)
# wks = sh.sheet1
#+end_src

   Now that the worksheet is selected, we can begin reading data.

#+begin_src ipython
row_vals = wks.row_values(1) # All values in row 1, stored in an array. 
col_vals = wks.col_values(1) # All values in column 1, stored in an array.

# This line gives you the first five values of row_vals and col_vals. Feel free
# to change around the indices to see more data, or skip to the next cell for a
# more holistic view.

row_vals[:5], col_vals[:5]
#+end_src

   A more standard usage of =gspread= is reading this data into a
   =pandas= dataframe. This next cell does exactly that. Feel free to
   use the exercises from Week 0 to refresh =pandas= specific
   functions to manipulate and explore the dataframe. 

#+begin_src ipython
import pandas as pd

data = wks.get_all_values()
headers = wks.pop(0)
data_df = pd.DataFrame(data,columns=headers)
data_df.head() 
#+end_src

   This is just a basic introduction to reading data from Google
   Spreadsheets using =GSpread=. For more information and
   documentation, visit https://gspread.readthedocs.io/en/latest/index.html.

** Writing Google Spreadsheet data

   In this section, we'll write data to a new Google
   Spreadsheet located here:
   https://docs.google.com/spreadsheets/d/1dhJUonTO5AcKgvLX06hjhyQOA9BtcUmVdKf-0eNIKzw/edit?usp=sharing.
   You'll notice that you can only view the spreadsheet, not
   edit. However, using the credentials provided to you previously,
   you'll be able to submit an indication of completion by writing
   your name in two places: =Master Sheet= and the tab corresponding
   to your team assignment. 

#+begin_src ipython
# This cell changes the spreadsheet and opens the first worksheet.
spreadsheet = '1dhJUonTO5AcKgvLX06hjhyQOA9BtcUmVdKf-0eNIKzw'
sh = gc.open_by_key(spreadsheet)
wks = gc.get_worksheet(0)
#+end_src

   Now that we're in the new spreadsheet and selected the first
   worksheet, open up the link above and identify the cell you want to
   put your name in. (Example: B3)

#+begin_src ipython
# Make sure to update 'cell' with the cell you would like to update, and 'your name'
# with your name!
wks.update_acell('CELL', 'YOUR NAME')

# Alternatively, you can update the cell using the following syntax:
#wks.update_cell(ROW_NUM, COL_NUM, 'YOUR NAME')
#+end_src

   If you look back at the spreadsheet, you should see your name in
   the cell you selected. Let's do it one more time in the tab with
   your team name. Try this one by yourself!

#+begin_src ipython
# HINT: Make sure to change the spreadsheet you've selected, look at the previous
# section for guidance on how to do this if you forgot.
#+end_src

   This concludes Week 1 exercises: reading and writing data to/from
   Google Spreadsheets programmatically using Python. One area not
   covered is writing entire =pandas= Dataframes to a spreadsheet. For
   larger datasets, its recommended to use the =gspread-dataframe=
   module instead of looping through and updating cells
   one-by-one. Check out this module here: https://pythonhosted.org/gspread-dataframe/.

* [EEP153] Week 3
  Some programming learning goals for week 3:
  1. List comprehensions
  2. Some string operations
  3. Understand simple recursions.
  4. Use lambda expressions (anonymous functions)
  5. Root-finding for equations of one variable
** List comprehensions
   You're already familiar with =for= loops like the following, which 
   computes the squares of a list of numbers:
   #+begin_src ipython
L = []
for i in [0,1,2]:
    L.append(i**2)

print(L)
   #+end_src
   This is pretty clear, but not very elegant.  Consider instead the
   following /list comprehension/:
   #+begin_src ipython
L = [i**2 for i in [0,1,2]]

print(L)
   #+end_src

** Simple recursions
   A recursion, or a recursive function, is a function that may call
   itself when evaluated.  Here's a very simple recursion:
   #+begin_src ipython
def foo(n):
    """Sum of postive integers up to n."""
    if n==0:
        return 0
    else:
        return n + foo(n-1)

foo(43)
   #+end_src
 
   The fact that evaluating =foo(n)= involves calling =foo(n-1)= is
   what makes this a recursion.

   If you give this even a little thought you'll be able to think of
   more efficient ways to do this; it's the demonstration of the
   simple pattern we're after.

   Here's another, which operates on lists of numbers:
   #+begin_src ipython
def bar(x):
    """What does this function do, and how does it do it?"""
    if x==[]: return 0 
    
    try:
        return bar(x[0]) + bar(x[1:])
    except TypeError: # x not a list?
        return x   
   #+end_src

   #+begin_src ipython
# Try calling bar after predicting its output:
bar([21,14,3,4])
   #+end_src

   The function =bar= also could be implemented much more efficiently!

   Finally, here's a function which /is/ useful (in fact, we'll use it
   below).  This takes a list (or tuple) which may consist of lists,
   and "flattens" it so that none of the elements are lists.  For
   example, =flatten([1,[2,3]]) -> [1,2,3]=.
   #+begin_src ipython
def flatten(a):
     if not isinstance(a,(tuple,list)): return [a]
     if len(a)==0: return []
     return flatten(a[0])+flatten(a[1:])

print(flatten([1,[2,3]]))
   #+end_src

** Some string operations
   We're interested here in a couple of simple ways to map strings
   into lists and lists into strings.  One common problem: you may
   have a string like "1,2,3,fiver".  
   #+begin_src ipython
s = "1,2,3,fiver"

# s can be treated like a list.  What is s[1]?
s[1]
   #+end_src

   So strings can be treated as lists of characters, at least for some
   purposes.  But the string above suggests a /different/ list, one
   with four elements.  To obtain this, consider
   #+begin_src ipython
t = s.split(',')
print(t)
   #+end_src

   We can also go the other way; given a list, we can turn it into a
   string, with the different elements separated by a string of our choice:
   #+begin_src ipython
" and ".join(t)
   #+end_src

   So how about using recursions and these string operations to
   actually do something useful?  Let's write a function that can take
   a string representing ranges of numbers, like "1,2-4,3-5,0-3" and
   return list of the numbers that appear (perhaps implicitly) in the
   string.
   #+begin_src ipython
def range_parser(s,unique=False):
    """
    Parse a string of numbers including ranges indicated by '-',
    and return a sorted list of all such numbers.

    If the optional flag unique is True, then return a list in
    which no numbers are repeated.

    Ethan Ligon                               February 2019
    """
    if unique:
        return sorted(list(set(range_parser(s,unique=False))))
    
    try: # Maybe we just have a single number, like '3'?
        return [int(s)]
    except ValueError:
        if ',' in s: # Or maybe we have a string with commas?
            return sorted(flatten([range_parser(x) for x in s.split(',')]))
        elif '-' in s:
            a,b = [range_parser(x)[0] for x in s.split('-')]
            return list(range(a,b))
        
print(range_parser("1,2-4,3-5,0-3",unique=True))
   #+end_src



** lambda expressions (anonymous functions)
   This is incredibly obvious to some people, but for others it takes
   some work to wrap their heads around.  But hopefully this will make
   this all obvious.  *Predict the output*:
   #+begin_src ipython
# Consider the two following functions

def f(x):
    return 1/x - 1

g = lambda x: 1/x -1

print(f(3) - g(3))
   #+end_src
   It may help to think of objects like =g= or =f= not as functions,
   but instead as names of or references to functions.

** Root-finding
   If we have a function (referred to by) =f= that takes a single
   scalar argument and returns a real number, then we may often be
   interesting in equations such as 
   \[
   f(x) = 0;
   \]
   the problem then is to find a value of $x$ that satisfies the
   equation.

   The first thing we might worry about is that no such solution
   exists.  Sometimes this is something we can check in advance.  For
   example, if can find a value $a$ such that =f(a)= is positive and a
   value $b$ such that =f(b)= is negative, the continuity of the
   function (named) =f= gives us a mathematical guarantee that a zero
   of the function exists.  

   However, even for continuous unbounded functions there is no
   algorithm that's guaranteed to locate a zero for /any/ such
   function.  Some algorithms work better than others, and some are
   designed to work with particular classes of functions.

   One quite robust (but often slow) method is a method called
   /bisection/.  This uses the idea above: start by finding values
   $(a,b)$  such that $f(a)>0>f(b)$.  Then if $f$ is continuous we
   know there must be a zero on the real interval $[a,b]$.  Divide
   this interval in half, and evaluate $f((a+b)/2)$.  If this is
   positive, then we know there must be a zero on the interval
   $[(a+b)/2,b]$; if negative, that there must be a zero on
   $[a,(a+b)/2]$.  Take this new smaller interval, and repeat.  Keep
   going until the evaluation of the function (named) =f= is close to
   zero.

   The python package =scipy= includes a module =optimize= which
   includes a variety of different routines to both find optima (i.e.,
   maxima and minima) as well as closely related routines to find the
   zeros of functions.  Here's an example of the use of the bisection
   algorithm:
   #+begin_src ipython
from scipy.optimize import bisect

x = bisect(lambda x: 1/x-1,.001,100)
print(x)
   #+end_src

   A much faster method is called the /secant/ method, and was known
   to the ancient Babylonians and Egyptians at least as early as 1800 BCE.
   The discovery of the calculus in the 18th century allowed Newton to
   improve on the secant method, but his approach requires not only
   the function be continuous, but also continuously differentiable;
   further, one must supply a function describing the derivatives.
   Both the secant method and Newton's method are available from
   =scipy.optimize=.
   #+begin_src ipython
from scipy.optimize import newton

# If we supply just a function and a starting place we
# get the secant method:
   
x = newton(f,1.01)  # Solution is one; if we start close we should find it!
print(x)  

x = newton(f,2)  # Not always robust!
print(x)
   #+end_src

   Now try Newton's method:
   #+begin_src ipython
df = lambda x: -x**(-2) # Derivative of function named f

# Supply derivative function, get Newton's method
x = newton(f,2,df)   # Still not necessarily robust!
print(x)
   #+end_src

   Newton's method works better with polynomials:
   #+begin_src ipython 
f = lambda x: -1 + x - 3*x**2 + 4*x**3

df = lambda x: 1 - 6*x +12*x**2

x = newton(f,10,df)
print(x)
   #+end_src


* [EEP153] Week 6
   :PROPERTIES:
   :CUSTOM_ID: eep-153-week-6
   :EXPORT_FILE_NAME: week6.ipynb
   :END:

Some programming learning goals for week 6:

1. String formatting and operations
2. Exceptions
3. More useful pandas practice

** 1. String Formatting Exercise 
   :PROPERTIES:
   :CUSTOM_ID: string-formatting-exercise
   :END:

Use https://pyformat.info as a reference. 

#+BEGIN_SRC ipython
myCat = { "Name":"Beatrice", "Age":7,"Nickname":"Queen B"}

# Exercise: Print out the string "My cat's name is Beatrice, but we usually call her Queen B."
#+END_SRC

*** 2. Errors 
    :PROPERTIES:
    :CUSTOM_ID: errors
    :END:

There are two types of errors: syntax errors, and exceptions.

Syntax errors occur when the parser detects an incorrect statement.
Exception errors occur when whenever syntactically correct Python code
results in an error. Python comes with various built-in exceptions as
well as the possibility to create self-defined exceptions.

**** Raising an exception
     :PROPERTIES:
     :CUSTOM_ID: raising-an-exception
     :END:

We can use raise to throw an exception if a condition occurs. For
example: run the code below, then un-comment the second line of code and
run again.

#+BEGIN_SRC ipython
x = '50'
#if isinstance(x,(str)): raise Exception('x should not be formatted as a string')
print(x)
#+END_SRC

**** Try, Except, Finally
     :PROPERTIES:
     :CUSTOM_ID: try-except-finally
     :END:

A try block lets you test a block of code for errors, an except block
lets you handle the error, and a finally block lets you execute code,
regardless of the result of the try- and except blocks. 

 You can have multiple except blocks, which allow you to
respond in a particular way to different types of errors.

 In the example below, try running the code as is, then
after un-commenting the first line. See you if you can fix the error.

#+BEGIN_SRC ipython
#w = 20
y = '25'
try:
    print('w = ' + w)
except NameError:
    print("Variable w is not defined")
except:  # You *can* catch all errors, but probably shouldn't.
    print("Something else went wrong")
finally:
    print('y = ' + y)
#+END_SRC

*** 3. More useful pandas practice
    :PROPERTIES:
    :CUSTOM_ID: more-useful-pandas-practice
    :END:

#+BEGIN_SRC ipython
import pandas as pd
import numpy as np

#sample dataset from https://ww2.amstat.org/censusatschool/
#+END_SRC

#+BEGIN_SRC ipython
#If your dataset is located in the same folder as your code, reading a CSV is straightforward:

df = pd.read_csv('Example_CAStudents.csv')
df.head()
#+END_SRC

#+BEGIN_SRC ipython
df.index
#+END_SRC

#+BEGIN_SRC ipython
df.columns
#+END_SRC

#+BEGIN_SRC ipython
#describe() shows a quick statistic summary of your data:
df.describe()
#+END_SRC

**** Quick manipulations
     :PROPERTIES:
     :CUSTOM_ID: quick-manipulations
     :END:

#+BEGIN_SRC ipython
#to transpose your data:
df.T

#to sort your data by a colum (say we wanted to sort by age, or the column 'Ageyears')
df.sort_values(by='Ageyears')
#+END_SRC

**** Selecting data
     :PROPERTIES:
     :CUSTOM_ID: selecting-data
     :END:

#+BEGIN_SRC ipython
#selecting a single column (these methods get the same result)
h_1 = df['Height_cm']
h_2 = df.Height_cm
#+END_SRC

#+BEGIN_SRC ipython
#selecting a subset of columns (note that both endpoints are included in the selection)
df.loc[:, ['Country','ClassGrade']]
#+END_SRC

#+BEGIN_SRC ipython
#selecting a subset of rows (note that the second endpoint is *not* included in the selection)
df[0:2]
#+END_SRC

#+BEGIN_SRC ipython
#getting a single value
df.at[1, 'Superpower']
#+END_SRC

#+BEGIN_SRC ipython
# Exercise: use pandas manipulations to construct a sub-dataset of the 5 tallest girls, sorted by age, 
#    and removing from the data all of the "hours" columns (ie Work_At_Home_Hours)

s = #your code here
#+END_SRC
